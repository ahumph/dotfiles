diff --git a/generic/tclCompCmds.c b/generic/tclCompCmds.c
index 5f4c298..ab122f9 100644
--- a/generic/tclCompCmds.c
+++ b/generic/tclCompCmds.c
@@ -489,6 +489,127 @@ TclCompileArrayUnsetCmd(
     PushStringLiteral(envPtr,	"");
     return TCL_OK;
 }
+
+int
+TclCompileArrayDefaultCmd(
+    Tcl_Interp *interp,		/* Used for looking up stuff. */
+    Tcl_Parse *parsePtr,	/* Points to a parse structure for the command
+				 * created by Tcl_ParseCommand. */
+    Command *cmdPtr,		/* Points to defintion of command being
+				 * compiled. */
+    CompileEnv *envPtr)		/* Holds resulting instructions. */
+{
+    DefineLineInformation;	/* TIP #280 */
+    Tcl_Token *dataTokenPtr;
+    int code = TCL_OK;
+    int isDataLiteral, isDataValid, isDataEven, len;
+    int keyVar, valVar, infoIndex;
+    int fwd, offsetBack, offsetFwd;
+    Tcl_Obj *literalObj;
+    ForeachInfo *infoPtr;
+
+    if (parsePtr->numWords != 3) {
+	return TCL_ERROR;
+    }
+
+    dataTokenPtr = TokenAfter(parsePtr->tokenPtr);
+    //dataTokenPtr = TokenAfter(varTokenPtr);
+    literalObj = Tcl_NewObj();
+    isDataLiteral = TclWordKnownAtCompileTime(dataTokenPtr, literalObj);
+    isDataValid = (isDataLiteral
+	    && Tcl_ListObjLength(NULL, literalObj, &len) == TCL_OK);
+    isDataEven = (isDataValid && (len & 1) == 0);
+
+    /*
+     * Special case: literal odd-length argument is always an error.
+     */
+
+    if (isDataValid && !isDataEven) {
+	PushStringLiteral(envPtr, "AH3 list must have an even number of elements");
+	PushStringLiteral(envPtr, "-errorcode {TCL ARGUMENT FORMAT}");
+	TclEmitInstInt4(INST_RETURN_IMM, TCL_ERROR,		envPtr);
+	TclEmitInt4(		0,				envPtr);
+	goto done;
+    }
+
+    /*
+     * Special case: literal empty value argument is just an "ensure array"
+     * operation.
+     */
+
+    if (isDataEven && len == 0) {
+    TclEmitOpcode(  INST_DUP,				envPtr);
+    TclEmitOpcode(  INST_ARRAY_EXISTS_STK,		envPtr);
+    TclEmitInstInt1(INST_JUMP_TRUE1, 5,			envPtr);
+    TclEmitOpcode(  INST_ARRAY_MAKE_STK,		envPtr);
+    TclEmitInstInt1(INST_JUMP1, 3,			envPtr);
+    /* Each branch decrements stack depth, but we only take one. */
+    TclAdjustStackDepth(1, envPtr);
+    TclEmitOpcode(  INST_POP,				envPtr);
+	PushStringLiteral(envPtr, "");
+	goto done;
+    }
+
+    /*
+     * Prepare for the internal foreach.
+     */
+
+    keyVar = AnonymousLocal(envPtr);
+    valVar = AnonymousLocal(envPtr);
+
+    infoPtr = ckalloc(sizeof(ForeachInfo));
+    infoPtr->numLists = 1;
+    infoPtr->varLists[0] = ckalloc(sizeof(ForeachVarList) + sizeof(int));
+    infoPtr->varLists[0]->numVars = 2;
+    infoPtr->varLists[0]->varIndexes[0] = keyVar;
+    infoPtr->varLists[0]->varIndexes[1] = valVar;
+    infoIndex = TclCreateAuxData(infoPtr, &newForeachInfoType, envPtr);
+
+    /*
+     * Start issuing instructions to write to the array.
+     */
+
+    CompileWord(envPtr, dataTokenPtr, interp, 2);
+    if (!isDataLiteral || !isDataValid) {
+	/*
+	 * Only need this safety check if we're handling a non-literal or list
+	 * containing an invalid literal; with valid list literals, we've
+	 * already checked (worth it because literals are a very common
+	 * use-case with [array set]).
+	 */
+
+	TclEmitOpcode(	INST_DUP,				envPtr);
+	TclEmitOpcode(	INST_LIST_LENGTH,			envPtr);
+	PushStringLiteral(envPtr, "1");
+	TclEmitOpcode(	INST_BITAND,				envPtr);
+	offsetFwd = CurrentOffset(envPtr);
+	TclEmitInstInt1(INST_JUMP_FALSE1, 0,			envPtr);
+	PushStringLiteral(envPtr, "AH2 list must have an even number of elements");
+	PushStringLiteral(envPtr, "-errorcode {TCL ARGUMENT FORMAT}");
+	TclEmitInstInt4(INST_RETURN_IMM, TCL_ERROR,		envPtr);
+	TclEmitInt4(		0,				envPtr);
+	TclAdjustStackDepth(-1, envPtr);
+	fwd = CurrentOffset(envPtr) - offsetFwd;
+	TclStoreInt1AtPtr(fwd, envPtr->codeStart+offsetFwd+1);
+    }
+
+    TclEmitInstInt1(INST_JUMP_TRUE1, 7,			envPtr);
+    TclEmitInstInt4(INST_FOREACH_START, infoIndex,	envPtr);
+    offsetBack = CurrentOffset(envPtr);
+    Emit14Inst(	INST_LOAD_SCALAR, keyVar,		envPtr);
+    Emit14Inst(	INST_LOAD_SCALAR, valVar,		envPtr);
+    TclEmitOpcode(	INST_POP,			envPtr);
+    infoPtr->loopCtTemp = offsetBack - CurrentOffset(envPtr); /*misuse */
+    TclEmitOpcode( INST_FOREACH_STEP,			envPtr);
+    TclEmitOpcode( INST_FOREACH_END,			envPtr);
+    TclAdjustStackDepth(-3, envPtr);
+    PushStringLiteral(envPtr,	"");
+
+    done:
+    Tcl_DecrRefCount(literalObj);
+    return code;
+}
+
 
 /*
  *----------------------------------------------------------------------
diff --git a/generic/tclInt.h b/generic/tclInt.h
index 3e55004..b80d602 100644
--- a/generic/tclInt.h
+++ b/generic/tclInt.h
@@ -2878,6 +2878,9 @@ MODULE_SCOPE void	TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
 			    CmdFrame **cfPtrPtr, int *wordPtr);
 MODULE_SCOPE int	TclArraySet(Tcl_Interp *interp,
 			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
+MODULE_SCOPE int	TclArrayDefault(Tcl_Interp *interp,
+			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
+MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
 MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
 MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
 			    int strLen, const unsigned char *pattern,
@@ -3503,6 +3506,9 @@ MODULE_SCOPE int	TclCompileArraySetCmd(Tcl_Interp *interp,
 MODULE_SCOPE int	TclCompileArrayUnsetCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, Command *cmdPtr,
 			    struct CompileEnv *envPtr);
+MODULE_SCOPE int	TclCompileArrayDefaultCmd(Tcl_Interp *interp,
+			    Tcl_Parse *parsePtr, Command *cmdPtr,
+			    struct CompileEnv *envPtr);
 MODULE_SCOPE int	TclCompileBreakCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, Command *cmdPtr,
 			    struct CompileEnv *envPtr);
diff --git a/generic/tclVar.c b/generic/tclVar.c
index 48e09f6..e12d29c 100644
--- a/generic/tclVar.c
+++ b/generic/tclVar.c
@@ -967,7 +967,8 @@ TclLookupArrayElement(
     int index)			/* If >=0, the index of the local array. */
 {
     int isNew;
-    Var *varPtr;
+    Var *varPtr, *defaultArrayPtr, *defaultVarPtr;
+    Tcl_Obj *arrayNameObj;
     TclVarHashTable *tablePtr;
     Namespace *nsPtr;
 
@@ -1026,20 +1027,33 @@ TclLookupArrayElement(
 	varPtr = VarHashCreateVar(arrayPtr->value.tablePtr, elNamePtr,
 		&isNew);
 	if (isNew) {
-	    if (arrayPtr->flags & VAR_SEARCH_ACTIVE) {
-		DeleteSearches((Interp *) interp, arrayPtr);
-	    }
-	    TclSetVarArrayElement(varPtr);
-	}
+        /*
+         * First try to get the default value, if it exists.
+         */
+        arrayNameObj = Tcl_NewStringObj("_array_defaults", -1);
+        defaultArrayPtr = TclObjLookupVarEx(interp, arrayNameObj, NULL, /*flags*/ 0,
+            /*msg*/ 0, /*createPart1*/ 0, /*createPart2*/ 0, &defaultArrayPtr);
+        if (defaultArrayPtr) {
+            defaultVarPtr = VarHashFindVar(defaultArrayPtr->value.tablePtr, arrayNamePtr);
+            if (defaultVarPtr) {
+                varPtr = defaultVarPtr;
+            }
+        } else {
+            if (arrayPtr->flags & VAR_SEARCH_ACTIVE) {
+            DeleteSearches((Interp *) interp, arrayPtr);
+            }
+            TclSetVarArrayElement(varPtr);
+        }
+    }
     } else {
 	varPtr = VarHashFindVar(arrayPtr->value.tablePtr, elNamePtr);
 	if (varPtr == NULL) {
-	    if (flags & TCL_LEAVE_ERR_MSG) {
-		TclObjVarErrMsg(interp, arrayNamePtr, elNamePtr, msg,
-			noSuchElement, index);
-		Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "ELEMENT",
-			TclGetString(elNamePtr), NULL);
-	    }
+        if (flags & TCL_LEAVE_ERR_MSG) {
+        TclObjVarErrMsg(interp, arrayNamePtr, elNamePtr, msg,
+            noSuchElement, index);
+        Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "ELEMENT",
+            TclGetString(elNamePtr), NULL);
+        }
 	}
     }
     return varPtr;
@@ -2767,7 +2781,7 @@ TclArraySet(
 	}
 	if (elemLen & 1) {
 	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
-		    "list must have an even number of elements", -1));
+		    "AH1 list must have an even number of elements", -1));
 	    Tcl_SetErrorCode(interp, "TCL", "ARGUMENT", "FORMAT", NULL);
 	    return TCL_ERROR;
 	}
@@ -2827,6 +2841,178 @@ TclArraySet(
     TclInitVarHashTable(varPtr->value.tablePtr, TclGetVarNsPtr(varPtr));
     return TCL_OK;
 }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TclArrayDefault --
+ *
+ *	Set the elements of an array. If there are no elements to set, create
+ *	an empty array. This routine is used by the Tcl_ArrayObjCmd and by the
+ *	TclSetupEnv routine.
+ *
+ * Results:
+ *	A standard Tcl result object.
+ *
+ * Side effects:
+ *	A variable will be created if one does not already exist.
+ *	Callers must Incr arrayNameObj if they pland to Decr it.
+ *
+ *----------------------------------------------------------------------
+ */
+
+int
+TclArrayDefault(
+    Tcl_Interp *interp,		/* Current interpreter. */
+    Tcl_Obj *arrayNameObj,	/* The array name. */
+    Tcl_Obj *arrayElemObj)	/* The array elements list or dict. If this is
+				 * NULL, create an empty array. */
+{
+    Var *varPtr, *arrayPtr;
+    int result, i;
+
+    varPtr = TclObjLookupVarEx(interp, arrayNameObj, NULL,
+	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "default", /*createPart1*/ 1,
+	    /*createPart2*/ 0, &arrayPtr);
+    if (varPtr == NULL) {
+	    TclObjVarErrMsg(interp, arrayNameObj, NULL, "array default",
+		    needArray, -1);
+	    Tcl_SetErrorCode(interp, "TCL", "WRITE", "ARRAY", NULL);
+	return TCL_ERROR;
+    }
+    if (arrayPtr) {
+	CleanupVar(varPtr, arrayPtr);
+	TclObjVarErrMsg(interp, arrayNameObj, NULL, "default", needArray, -1);
+	Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "VARNAME",
+		TclGetString(arrayNameObj), NULL);
+	return TCL_ERROR;
+    }
+
+    if (arrayElemObj == NULL) {
+	goto ensureArray;
+    }
+
+    /*
+     * Install the contents of the dictionary or list into the array.
+     */
+
+    if (arrayElemObj->typePtr == &tclDictType) {
+	Tcl_Obj *keyPtr, *valuePtr;
+	Tcl_DictSearch search;
+	int done;
+
+	if (Tcl_DictObjSize(interp, arrayElemObj, &done) != TCL_OK) {
+	    return TCL_ERROR;
+	}
+	if (done == 0) {
+	    /*
+	     * Empty, so we'll just force the array to be properly existing
+	     * instead.
+	     */
+
+	    goto ensureArray;
+	}
+
+	/*
+	 * Don't need to look at result of Tcl_DictObjFirst as we've just
+	 * successfully used a dictionary operation on the same object.
+	 */
+
+	for (Tcl_DictObjFirst(interp, arrayElemObj, &search,
+		&keyPtr, &valuePtr, &done) ; !done ;
+		Tcl_DictObjNext(&search, &keyPtr, &valuePtr, &done)) {
+	    /*
+	     * At this point, it would be nice if the key was directly usable
+	     * by the array. This isn't the case though.
+	     */
+
+	    Var *elemVarPtr = TclLookupArrayElement(interp, arrayNameObj,
+		    keyPtr, TCL_LEAVE_ERR_MSG, "default", 1, 1, varPtr, -1);
+
+	    if ((elemVarPtr == NULL) ||
+		    (TclPtrSetVar(interp, elemVarPtr, varPtr, arrayNameObj,
+		    keyPtr, valuePtr, TCL_LEAVE_ERR_MSG, -1) == NULL)) {
+		Tcl_DictObjDone(&search);
+		return TCL_ERROR;
+	    }
+	}
+	return TCL_OK;
+    } else {
+	/*
+	 * Not a dictionary, so assume (and convert to, for backward-
+	 * -compatability reasons) a list.
+	 */
+
+	int elemLen;
+	Tcl_Obj **elemPtrs, *copyListObj;
+
+	result = TclListObjGetElements(interp, arrayElemObj,
+		&elemLen, &elemPtrs);
+	if (result != TCL_OK) {
+	    return result;
+	}
+	if (elemLen & 1) {
+	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
+		    "list must have an even number of elements", -1));
+	    Tcl_SetErrorCode(interp, "TCL", "ARGUMENT", "FORMAT", NULL);
+	    return TCL_ERROR;
+	}
+	if (elemLen == 0) {
+	    goto ensureArray;
+	}
+
+	/*
+	 * We needn't worry about traces invalidating arrayPtr: should that be
+	 * the case, TclPtrSetVar will return NULL so that we break out of the
+	 * loop and return an error.
+	 */
+
+	copyListObj = TclListObjCopy(NULL, arrayElemObj);
+	for (i=0 ; i<elemLen ; i+=2) {
+	    Var *elemVarPtr = TclLookupArrayElement(interp, arrayNameObj,
+		    elemPtrs[i], TCL_LEAVE_ERR_MSG, "default", 1, 1, varPtr, -1);
+
+	    if ((elemVarPtr == NULL) ||
+		    (TclPtrSetVar(interp, elemVarPtr, varPtr, arrayNameObj,
+		    elemPtrs[i],elemPtrs[i+1],TCL_LEAVE_ERR_MSG,-1) == NULL)){
+		result = TCL_ERROR;
+		break;
+	    }
+	}
+	Tcl_DecrRefCount(copyListObj);
+	return result;
+    }
+
+    /*
+     * The list is empty make sure we have an array, or create one if
+     * necessary.
+     */
+
+  ensureArray:
+    if (varPtr != NULL) {
+	if (TclIsVarArray(varPtr)) {
+	    /*
+	     * Already an array, done.
+	     */
+
+	    return TCL_OK;
+	}
+	if (TclIsVarArrayElement(varPtr) || !TclIsVarUndefined(varPtr)) {
+	    /*
+	     * Either an array element, or a scalar: lose!
+	     */
+
+	    TclObjVarErrMsg(interp, arrayNameObj, NULL, "array default",
+		    needArray, -1);
+	    Tcl_SetErrorCode(interp, "TCL", "WRITE", "ARRAY", NULL);
+	    return TCL_ERROR;
+	}
+    }
+    TclSetVarArray(varPtr);
+    varPtr->value.tablePtr = ckalloc(sizeof(TclVarHashTable));
+    TclInitVarHashTable(varPtr->value.tablePtr, TclGetVarNsPtr(varPtr));
+    return TCL_OK;
+}
 
 /*
  *----------------------------------------------------------------------
@@ -3671,6 +3857,68 @@ ArraySetCmd(
 
     return TclArraySet(interp, objv[1], objv[2]);
 }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * ArrayDefaultCmd --
+ *
+ *	This object-based function is invoked to process the "array set" Tcl
+ *	command. See the user documentation for details on what it does.
+ *
+ * Results:
+ *	A standard Tcl result object.
+ *
+ * Side effects:
+ *	See the user documentation.
+ *
+ *----------------------------------------------------------------------
+ */
+
+	/* ARGSUSED */
+static int
+ArrayDefaultCmd(
+    ClientData clientData,
+    Tcl_Interp *interp,
+    int objc,
+    Tcl_Obj *const objv[])
+{
+    Interp *iPtr = (Interp *) interp;
+    Var *varPtr, *arrayPtr;
+    Tcl_Obj *arrayNameObj, *createNewObj;
+
+    if (objc != 2) {
+	Tcl_WrongNumArgs(interp, 1, objv, "list ?createNew?");
+	return TCL_ERROR;
+    }
+
+    createNewObj = (objc > 1 ? objv[objc-1] : NULL);
+
+    /*
+     * Locate the array variable.
+     */
+
+    varPtr = TclObjLookupVarEx(interp, objv[1], NULL, /*flags*/ 0,
+	    /*msg*/ 0, /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
+
+    /*
+     * Special array trace used to keep the env array in sync for array names,
+     * array get, etc.
+     */
+
+    if (varPtr && (varPtr->flags & VAR_TRACED_ARRAY)
+	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
+	if (TclObjCallVarTraces(iPtr, arrayPtr, varPtr, objv[1], NULL,
+		(TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY|
+		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1, -1) == TCL_ERROR) {
+	    return TCL_ERROR;
+	}
+    }
+
+    arrayNameObj = Tcl_NewStringObj("_array_defaults", -1);
+
+    return TclArrayDefault(interp, arrayNameObj, objv[1]);
+}
 
 /*
  *----------------------------------------------------------------------
@@ -4030,6 +4278,7 @@ TclInitArrayCmd(
 	{"names",	ArrayNamesCmd,		TclCompileBasic1To3ArgCmd, NULL, NULL, 0},
 	{"nextelement",	ArrayNextElementCmd,	TclCompileBasic2ArgCmd, NULL, NULL, 0},
 	{"set",		ArraySetCmd,		TclCompileArraySetCmd, NULL, NULL, 0},
+	{"default",		ArrayDefaultCmd,		TclCompileArrayDefaultCmd, NULL, NULL, 0},
 	{"size",	ArraySizeCmd,		TclCompileBasic1ArgCmd, NULL, NULL, 0},
 	{"startsearch",	ArrayStartSearchCmd,	TclCompileBasic1ArgCmd, NULL, NULL, 0},
 	{"statistics",	ArrayStatsCmd,		TclCompileBasic1ArgCmd, NULL, NULL, 0},
